<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <link type="text/css" rel="stylesheet" href="../styles/style.css">
    <link type="text/css" rel="stylesheet" href="../styles/jquery.nouislider.min.css">
    <link type="text/css" rel="stylesheet" href="../styles/jquery.nouislider.pips.min.css">

    <script src="../javascript/moment.min.js"></script>
    <script src="../javascript/numeral.min.js"></script>
    <script src="../javascript/d3.v2.min.js"></script>
    <script src="../javascript/jquery-1.11.1.min.js"></script>
    <script src="../javascript/jquery.nouislider.all.min.js"></script>
    <script src="../javascript/d3.v2.min.js"></script>
    <style>

        .node {
            stroke: #fff;
            stroke-width: 1.5px;
        }

        .link {
            stroke: #999;
            stroke-opacity: .6;
        }

        .noUi-horizontal .noUi-handle {
            width: 20px;
        }

    </style>
</head>
<body>
<h1><i>Routing Form</i> Co-occurrence</h1>
<aside style="margin-top:80px;">
    <p>Filter: <select id="college">
    </select>
    </p>

    <p>First Collaborations Between PIs Occurring from:<span id='latest_date'>Jan 1, 2011</span>
    </p>

    <p>
    <div id="slider"></div>
    <br/>
        Add and remove PIs when filtering: <input id='add_remove' name='add_remove' type="checkbox" checked>
    </p>


    <p>This force directed graph visualizes co-occurrences in Routing Forms by PI.

    </p>

    <p>Each colored dot represents a PI. Bolder links indicate the dollar value of the collaboration.
        Hover over dots to see more information about PIs.
        Hover over links to see the value of the collaboration)


    </p>

    <p>Built with <a href="http://d3js.org/">d3.js</a>.
    </p>

    <p>
    <dl id="colors">
    </dl>
    </p>
</aside>
<script>


var width = 1080,
        height = 800;

$("#slider").noUiSlider({
    start: [ 1, 3 ],
    behaviour: 'drag',
    connect: true,
    range: {
        'min':  0,
        'max':  7
    },
    step: 1,
    margin: 1
})
        .change(function() {
            show_date();
            jump();
        }
);


var color = d3.scale.category20();
var charge_scale = d3.scale.linear().domain([0,1400]).range([-30, -10]);
var link_scale = d3.scale.linear().domain([0,1400]).range([40,25]);

var svg = d3.select("body").append("svg")
        .attr('class', 'main_svg')
        .attr("width", width)
        .attr("height", height);

var college_selected = 'all';
var college_name = 'All (over 800 people)';
var scale = d3.scale.pow()
        .domain([0, 30000000])
        .range([2, 12]);
var latest_link_dates = [
    new Date(2011, 6, 1),
    new Date(2012, 0, 1),
    new Date(2012, 6, 1),
    new Date(2013, 0, 1),
    new Date(2013, 6, 1),
    new Date(2014, 0, 1),
    new Date(2014, 6, 1),
    new Date(2015, 0, 1)
];


var first_link_dte = latest_link_dates[1];
var last_link_dte = latest_link_dates[3];

function show_date() {
    sliders = $('#slider').val();
    first_link_dte = latest_link_dates[Math.floor(sliders[0])];
    last_link_dte = latest_link_dates[Math.floor(sliders[1])];
    d3.select('#latest_date').text(moment(first_link_dte).format('M/D/YYYY') + " to " +moment(last_link_dte).format('M/D/YYYY') );
}
show_date();
d3.select("svg.main_svg").remove();

var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

d3.json("only_all.json", function (all) {
    college_list = all.colleges;
    //college_list.push ({"college": 'Engelhardt, John', "key": 'engelhardt'})
    d3.select('#college')
            .selectAll('option')
            .data(college_list)
            .enter()
            .append('option')
            .attr("value", function (d) {
                return d.key;
            })
            .attr("selected", function (d) {
                return d.key == college_selected ? 'true' : null;
            })
            .text(function (d) {
                return d.college;
            });
    color = d3.scale.category20().domain(college_list.map(function (college) {
        return college.college
    }));
    map_colleges(college_list);

    setup(all);
});


var links = [];
var mapped_links = [];
var nodes = [];
var typed_nodes = [];
var mapped_colleges = [];
var clusters = [];
var padding = 5.5, // separation between same-color circles
        clusterPadding = 6, // separation between different-color circles
        maxRadius = 12;

var force = d3.layout.force()
        .charge(-10)
        .linkDistance(25)
        .size([width, height])
        .nodes(nodes)
        .links(links)
        .on("tick", tick);

var link = svg.selectAll('.link'),
        node = svg.selectAll('.node');


function filter_links(earliest_date, latest_date) {

    filtered_nodes = {};

    links = mapped_links.filter(function (d) {
        var match_college = d.source.pi_college == college_name;
        match_college = match_college || d.target.pi_college == college_name;
        match_college = match_college || college_selected == 'all';
        match_college = match_college || d.target.pi == college_name;
        match_college = match_college || d.source.pi == college_name;
        var is_match = d.earliest_collaboration >= earliest_date && d.earliest_collaboration <= latest_date && (match_college);
        if (is_match) {
            filtered_nodes[d.target.rank] = d.target;
            filtered_nodes[d.source.rank] = d.source;
        }
        return is_match;
    });

    if (d3.select('#add_remove').property('checked')) {
        nodes = d3.values(filtered_nodes);
        } else {
        nodes = typed_nodes;
    }
    force.charge(charge_scale(nodes.length));
    force.linkDistance(link_scale(nodes.length));
    force.nodes(nodes);
    draw_nodes();

    force.links(links);
    link = svg.selectAll('.link');
    link = link.data(force.links(), function (d) {
        return d.source.rank + "-" + d.target.rank;
    });
    link.enter().append("line")
            .attr("class", "link")
            .style("stroke-width", function (d) {
                return scale(d.value);
            });
    link.append('title')
            .text(function(d) {
                return numeral(d.value == 1 ? 0: d.value).format('$0,0') ;});
    link.exit().remove();
}

function map_links(raw_links, nodes) {
    raw_links.forEach(function (link) {
        mapped_links.push({ source: nodes[link.source],
            target: nodes[link.target],
            value: link.value,
            earliest_collaboration: new Date(link.earliest_collaboration)})
    });
}

function type_nodes(raw_nodes) {
    raw_nodes.forEach(function (d) {
        d.type = map_type(d.pi_college);
        if (!clusters[d.type]) {
            clusters[d.type] = d;
        }
        typed_nodes.push(d)
    });
}

function map_colleges(college_list) {
    var i = 0;
    college_list.forEach(function (d) {
        mapped_colleges[d.college] = i++;
        if (d.key != 'all') {
            d3.select("#colors")
                    .append("dt")
                    .text(d.college)
                    .append('dd')
                    .text('Investigators')
                    .style("background-color", color(d.college));
        }
    });
}

function map_type(college_name) {
    return mapped_colleges[college_name];
}

function setup(data) {
    raw_links = data.links;
    type_nodes(data.nodes);
    nodes = typed_nodes;
    map_links(raw_links, nodes);
    links = mapped_links;
    force.nodes(nodes);
    draw_nodes();

    jump();
}

function draw_nodes() {
    node = node.data(force.nodes(), function (d) {
        return d.rank;
    })
    node.enter().append("circle")
            .attr("class", "node")
            .attr("r", 6)
            .style("fill", function (d) {
                return color(d.pi_college);
            })
            .call(force.drag);
    node.append("title")
            .text(function (d) {
                return d.pi + " -- College: " + d.pi_college + ", Department: " + d.pi_department;
            });
    node.exit().remove();

}


function jump() {

    filter_links(first_link_dte, last_link_dte);
    force.start();

}

d3.select("input[type=checkbox]").on("change", function () {
    jump();
});


function tick(e) {
    link.attr("x1", function (d) {
        var deltaX = d.target.x - d.source.x,
                deltaY = d.target.y - d.source.y,
                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                normX = deltaX / dist,
                normY = deltaY / dist,
                sourcePadding = d.left ? 11 : 6,
                targetPadding = d.right ? 11 : 6,
                sourceX = d.source.x + (sourcePadding * normX),
                sourceY = d.source.y + (sourcePadding * normY),
                targetX = d.target.x - (targetPadding * normX),
                targetY = d.target.y - (targetPadding * normY);
        return sourceX;
    })
            .attr("y1", function (d) {
                var deltaX = d.target.x - d.source.x,
                        deltaY = d.target.y - d.source.y,
                        dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                        normX = deltaX / dist,
                        normY = deltaY / dist,
                        sourcePadding = d.left ? 11 : 6,
                        targetPadding = d.right ? 11 : 6,
                        sourceX = d.source.x + (sourcePadding * normX),
                        sourceY = d.source.y + (sourcePadding * normY),
                        targetX = d.target.x - (targetPadding * normX),
                        targetY = d.target.y - (targetPadding * normY);
                return sourceY;
            })
            .attr("x2", function (d) {
                var deltaX = d.target.x - d.source.x,
                        deltaY = d.target.y - d.source.y,
                        dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                        normX = deltaX / dist,
                        normY = deltaY / dist,
                        sourcePadding = d.left ? 11 : 6,
                        targetPadding = d.right ? 11 : 6,
                        sourceX = d.source.x + (sourcePadding * normX),
                        sourceY = d.source.y + (sourcePadding * normY),
                        targetX = d.target.x - (targetPadding * normX),
                        targetY = d.target.y - (targetPadding * normY);
                return targetX;
            })
            .attr("y2", function (d) {
                var deltaX = d.target.x - d.source.x,
                        deltaY = d.target.y - d.source.y,
                        dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                        normX = deltaX / dist,
                        normY = deltaY / dist,
                        sourcePadding = d.left ? 11 : 6,
                        targetPadding = d.right ? 11 : 6,
                        sourceX = d.source.x + (sourcePadding * normX),
                        sourceY = d.source.y + (sourcePadding * normY),
                        targetX = d.target.x - (targetPadding * normX),
                        targetY = d.target.y - (targetPadding * normY);
                return targetY;
            });

    node.attr("cx", function (d) {
        return d.x;
    })
            .attr("cy", function (d) {
                return d.y;
            });
}

function truncate_pi(pi) {
    rval = pi.split(',')[0] + ',';
    rval = rval + pi.split(',')[1][1];
    return rval;
}

d3.select("#college").on("change", function () {
    college_selected = this.value;
    college_name = this.selectedOptions.item().text
    jump();
});

// Move d to be adjacent to the cluster node.
function cluster(alpha) {
    return function (d) {
        var cluster = clusters[d.type];
        if (cluster === d) return;
        var x = d.x - cluster.x,
                y = d.y - cluster.y,
                l = Math.sqrt(x * x + y * y),
                r = d.radius + cluster.radius;
        if (l != r) {
            l = (l - r) / l * alpha;
            d.x -= x *= l;
            d.y -= y *= l;
            cluster.x += x;
            cluster.y += y;
        }
    };
}


// Resolves collisions between d and all other circles.
function collide(alpha) {
    var quadtree = d3.geom.quadtree(nodes);
    return function (d) {
        var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                nx1 = d.x - r,
                nx2 = d.x + r,
                ny1 = d.y - r,
                ny2 = d.y + r;
        quadtree.visit(function (quad, x1, y1, x2, y2) {
            if (quad.point && (quad.point !== d)) {
                var x = d.x - quad.point.x,
                        y = d.y - quad.point.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
                if (l < r) {
                    l = (l - r) / l * alpha;
                    d.x -= x *= l;
                    d.y -= y *= l;
                    quad.point.x += x;
                    quad.point.y += y;
                }
            }
            return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            tick

        });
    };
}

</script>
</body>
</html>

