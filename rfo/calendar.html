<html>
<head>
    <title>Swimlane using d3.js</title>
    <link type="text/css" rel="stylesheet" href="styles/style.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery-ui.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery-ui.structure.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery-ui.theme.min.css">

    <!-- bower:css -->
    <link rel="stylesheet" href="bower_components/nouislider/distribute/jquery.nouislider.min.css" />
    <link rel="stylesheet" href="bower_components/nouislider/distribute/jquery.nouislider.pips.min.css" />
    <link rel="stylesheet" href="bower_components/qtip2/jquery.qtip.css" />
    <link rel="stylesheet" href="bower_components/bootstrap/docs/assets/css/bootstrap.css" />
    <link rel="stylesheet" href="bower_components/bootstrap-css/css/bootstrap.min.css" />
    <!-- endbower -->

    <!-- bower:js -->
    <script src="bower_components/modernizr/modernizr.js"></script>
    <script src="bower_components/jquery/jquery.js"></script>
    <script src="bower_components/underscore/underscore.js"></script>
    <script src="bower_components/jquery-ui/jquery-ui.js"></script>
    <script src="bower_components/moment/moment.js"></script>
    <script src="bower_components/numeral/numeral.js"></script>
    <script src="bower_components/nouislider/distribute/jquery.nouislider.all.min.js"></script>
    <script src="bower_components/ericmmartin.simplemodal/src/jquery.simplemodal.js"></script>
    <script src="bower_components/eventEmitter/EventEmitter.js"></script>
    <script src="bower_components/eventie/eventie.js"></script>
    <script src="bower_components/imagesloaded/imagesloaded.js"></script>
    <script src="bower_components/qtip2/jquery.qtip.js"></script>
    <script src="bower_components/bootstrap/docs/assets/js/bootstrap.js"></script>
    <script src="bower_components/d3/d3.js"></script>
    <script src="bower_components/dimple/dist/dimple.v2.1.6.min.js"></script>
    <script src="bower_components/bootstrap-css/js/bootstrap.min.js"></script>
    <!-- endbower -->

    <script src="javascript/sharedv2.js"></script>

    <style>
        .chart {
            shape-rendering: crispEdges;
        }

        .mini text {
            font: 9px sans-serif;
        }

        .mini text.small {
            font-size: 7px;
        }

        .main text {
            font: 12px sans-serif;
        }

        .main text.small {
            font-size: 9px;
        }

        .month text {
            text-anchor: start;
        }

        .todayLine {
            stroke: blue;
            stroke-width: 1.5;
        }

        .axis line, .axis path {
            stroke: black;
        }

        .miniItem {
            stroke-width: 6;
        }

        .past.pi {
            stroke: #9BD63A;
            fill: #9BD63A;
            stroke-opacity: 20%;
            fill-opacity: 20%;
        }

        .future.pi {
            stroke: #C4D6A5;
            fill: #C4D6A5;
            stroke-opacity: 20%;
            fill-opacity: 20%;
        }

        .past.investigator {
            stroke: #5B76E3;
            fill: #5B76E3;
            stroke-opacity: 20%;
            fill-opacity: 20%;
        }

        .future.investigator {
            stroke: #B4C0ED;
            fill: #B4C0ED;
            stroke-opacity: 20%;
            fill-opacity: 20%;
        }

        .past.technician {
            stroke: #E39714;
            fill: #E39714;
            stroke-opacity: 20%;
            fill-opacity: 20%;
        }

        .future.technician {
            stroke: #DEC67E;
            fill: #DEC67E;
            stroke-opacity: 20%;
            fill-opacity: 20%;
        }

        .future.awarded, .past.awarded {
            fill-opacity: 100%;
            stroke-opacity: 100%;
        }

        .brush .extent {
            stroke: gray;
            fill: blue;
            fill-opacity: .165;
        }

        .calendar-tip {
            max-width: 340px;
            font-size: 14px;
            line-height: 1.5em;
        }
    </style>
</head>
<body>
<div id="config_starter"><img src="img/gear.png" id="open_config" style="width:30px; height: 30px;" title='open settings' alt="control to open or close settings"/></div>
<div id="config">
    <div id="filters" style="width: 40%; border: 1px solid black; margin: 5px; padding: 5px; z-index: 30;;" class='config_overlay'>
        <label for="autofilter">Filter</label> <img src="img/x.png" id='close_config' style="position: absolute; right: 0px; top: 0px;" title='close settings' alt="control to open or close settings" />
        <input id="autofilter" type="text">

        <div id="selected_filters">
        </div>

        <div id="checkboxes">
            <input type="checkbox" name='filter_pi' value="pi" checked>Include Items where Researcher is PI</input>
            <br/>
            <input type="checkbox" name='filter_investigator' value="investigator" checked>Include Items where Researcher is a
            Co-Investigator</input>
            <br/>
            <input type="checkbox" name='filter_technician' value="technician" checked>Include Items where Researcher is a
            Technician</input>
            <br/>
        </div>

    </div>


</div>

<script type="text/javascript">
var lanes, items, now, lane_map;
var autocomplete_source;
var selected_researcher = 1291;
var all_lanes, all_items;

var sort_scale = d3.scale.ordinal().domain(['PI', 'Investigator', 'Technician']).range([0,1,2]);



d3.json("data/swimlane.json", function (data) {

    lanes = data.lanes;
    items = data.items;
    all_items = items;
    all_lanes = lanes;

    all_items.forEach(function (d) {
        d.start = new Date(d.start + " GMT-0500");
        d.end = new Date(d.end + " GMT-0500");
    });

    now = new Date();

    filter_data();

    autocomplete_source = data.nodes.map(function (researcher) {
        return { label: "Researcher: " + researcher.display_name_reverse, value: researcher.user_id };
    });
    $('#autofilter').autocomplete({
        source: autocomplete_source,
        select: set_selected_pi
    });

    $('#open_config').on('click', function () {
        $('#filters').toggleClass('ui-helper-hidden-accessible')
                .toggleClass('position_absolute');
    });

    $('#close_config').on('click', function() {$('#filters').toggleClass('ui-helper-hidden-accessible').toggleClass('position_absolute'); });

    $('#filters [type=checkbox]').on('click', function() { filter_data(); $('svg').remove(); everything(); });

    function set_selected_pi(event, ui) {
        selected_researcher = ui.item.value;
        $('#autofilter').val(ui.item.label);
        filter_data();
        $('svg').remove();
        everything();
        return false;
    }

    function filter_data() {

        // find just the right lanes


        selected_roles = [];

        $("#filters [type=checkbox]:checked").map(function (i, val) {
            selected_roles.push($(val).val());
        });

        lanes = all_lanes.filter(function (d) {
            user_match = d.user_id == selected_researcher;
            role_match = $.inArray(d.role.toLowerCase(), selected_roles) > -1;
            return user_match && role_match;
        });
        lane_ids = lanes.map(function (d) {
            return d.id;
        });

        // find just the right items
        items = all_items.filter(function (d) {
            lane_match = $.inArray(d.lane, lane_ids) > -1;
            return lane_match;
        });
    }

    everything();

    var margin, x, x1, ext, y1, y2, chart, main, mini, x1DateAxis, xDateAxis;
    var xMonthAxis, x1MonthAxis, itemRects, brush;



    function everything() {


        lanes = lanes.sort(function (a, b) {
            rval = sort_scale(a.role) - sort_scale(b.role);
            return rval;
//
//            if (a.role < b.role)
//                return 1;
//            else if (a.role > b.role)
//                return -1;
//            else
//                return 0;
        });


        lane_map = map_lanes(lanes);

        margin = {top: 20, right: 15, bottom: 15, left: 60, text: 200 }
                , width = 1080 - margin.left - margin.right
                , height = 1000 - margin.top - margin.bottom
                , miniHeight = lanes.length * 12 + 50
                , mainHeight = height - miniHeight - 50;

        x = d3.time.scale()
                .domain([d3.time.sunday(d3.min(items, function (d) {
                    return d.start;
                })),
                    d3.max(items, function (d) {
                        return d.end;
                    })])
                .range([0, width]);
        x1 = d3.time.scale().range([0, width]);

        ext = d3.extent(lanes, function (d) {
            return d.position;
        });
        y1 = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, mainHeight]);
        y2 = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, miniHeight]);

        chart = d3.select('body')
                .append('svg:svg')
                .attr('width', width + margin.right + margin.left + margin.text)
                .attr('height', height + margin.top + margin.bottom)
                .attr('class', 'chart');

        chart.append('defs').append('clipPath')
                .attr('id', 'clip')
                .append('rect')
                .attr('width', width)
                .attr('height', mainHeight);


        var left_of_lanes = margin.left + margin.text;

        main = chart.append('g')
                .attr('transform', 'translate(' + left_of_lanes + ',' + margin.top + ')')
                .attr('width', width)
                .attr('height', mainHeight)
                .attr('class', 'main');

        mini = chart.append('g')
                .attr('transform', 'translate(' + left_of_lanes + ',' + (mainHeight + 60) + ')')
                .attr('width', width)
                .attr('height', miniHeight)
                .attr('class', 'mini');

// draw the lanes for the main chart
        main.append('g').selectAll('.laneLines')
                .data(lanes)
                .enter().append('line')
                .attr('x1', 0)
                .attr('y1', function (d) {
                    return d3.round(y1(d.position)) + 0.5;
                })
                .attr('x2', width)
                .attr('y2', function (d) {
                    return d3.round(y1(d.position)) + 0.5;
                })
                .attr('stroke', function (d) {
                    return d.label === '' ? 'white' : 'lightgray'
                });

        var medium_length = 40,
                max_length = 57;

        function make_lane_text(d) {
            var lane_text = d.label;
            if (lane_text.length > max_length) {
                lane_text = lane_text.substring(0, max_length - 4) + "...";
            }
            return lane_text;
        }

        function lane_class(d) {
            var small = '';
            if (d.label.length > medium_length) small = " small";
            return 'laneText' + small;
        }

        main.append('g').selectAll('.laneText')
                .data(lanes)
                .enter().append('text')
                .text(make_lane_text)
                .attr('x', -10)
                .attr('y', function (d) {
                    return y1(d.position + .5);
                })
                .attr('dy', '0.5ex')
                .attr('text-anchor', 'end')
                .attr('data-rect-tip', lane_text_html)
                .attr('class', lane_class);

// draw the lanes for the mini chart
        mini.append('g').selectAll('.laneLines')
                .data(lanes)
                .enter().append('line')
                .attr('x1', 0)
                .attr('y1', function (d) {
                    return d3.round(y2(d.position)) + 0.5;
                })
                .attr('x2', width)
                .attr('y2', function (d) {
                    return d3.round(y2(d.position)) + 0.5;
                })
                .attr('stroke', function (d) {
                    return d.label === '' ? 'white' : 'lightgray'
                });

        mini.append('g').selectAll('.laneText')
                .data(lanes)
                .enter().append('text')
                .text(make_lane_text)
                .attr('x', -10)
                .attr('y', function (d) {
                    return y2(d.position + .5);
                })
                .attr('dy', '0.5ex')
                .attr('text-anchor', 'end')
                .attr('data-rect-tip', lane_text_html)
                .attr('class', lane_class);

// draw the x axis
        xDateAxis = d3.svg.axis()
                .scale(x)
                .orient('bottom')
                .ticks(d3.time.months, (x.domain()[1] - x.domain()[0]) > 15552e6 ? 2 : 1)
                .tickFormat(d3.time.format('%b'))
                .tickSize(6, 0, 0);

        x1DateAxis = d3.svg.axis()
                .scale(x1)
                .orient('bottom')
                .ticks(d3.time.days, 1)
                .tickFormat(d3.time.format('%a %d'))
                .tickSize(6, 0, 0);

        xMonthAxis = d3.svg.axis()
                .scale(x)
                .orient('top')
                .ticks(d3.time.years, 1)
                .tickFormat(d3.time.format('%Y'))
                .tickSize(15, 0, 0);

        x1MonthAxis = d3.svg.axis()
                .scale(x1)
                .orient('top')
                .ticks(d3.time.mondays, 1)
                .tickFormat(d3.time.format('%b - Week %W'))
                .tickSize(15, 0, 0);

        main.append('g')
                .attr('transform', 'translate(0,' + mainHeight + ')')
                .attr('class', 'main axis date')
                .call(x1DateAxis);

        main.append('g')
                .attr('transform', 'translate(0,0.5)')
                .attr('class', 'main axis month')
                .call(x1MonthAxis)
                .selectAll('text')
                .attr('dx', 5)
                .attr('dy', 12);

        mini.append('g')
                .attr('transform', 'translate(0,' + miniHeight + ')')
                .attr('class', 'axis date')
                .call(xDateAxis);

        mini.append('g')
                .attr('transform', 'translate(0,0.5)')
                .attr('class', 'axis month')
                .call(xMonthAxis)
                .selectAll('text')
                .attr('dx', 5)
                .attr('dy', 12);

// draw a line representing today's date
        main.append('line')
                .attr('y1', 0)
                .attr('y2', mainHeight)
                .attr('class', 'main todayLine')
                .attr('clip-path', 'url(#clip)');

        mini.append('line')
                .attr('x1', x(now) + 0.5)
                .attr('y1', 0)
                .attr('x2', x(now) + 0.5)
                .attr('y2', miniHeight)
                .attr('class', 'todayLine');

// draw the items
        itemRects = main.append('g')
                .attr('clip-path', 'url(#clip)');

        mini.append('g').selectAll('miniItems')
                .data(getPaths(items))
                .enter().append('path')
                .attr('class', function (d) {
                    return 'miniItem ' + d.class;
                })
                .attr('d', function (d) {
                    return d.path;
                });

// invisible hit area to move around the selection window
        mini.append('rect')
                .attr('pointer-events', 'painted')
                .attr('width', width)
                .attr('height', miniHeight)
                .attr('visibility', 'hidden')
                .on('mouseup', moveBrush);

// draw the selection area
        brush = d3.svg.brush()
                .x(x)
                .extent([d3.time.monday(now), d3.time.saturday.ceil(now)])
                .on("brush", display);

        mini.append('g')
                .attr('class', 'x brush')
                .call(brush)
                .selectAll('rect')
                .attr('y', 1)
                .attr('height', miniHeight - 1);

        mini.selectAll('rect.background').remove();
        display();
    }


    function item_class(d, type) {
        var awarded_class = '';
        var role = (lane_map[d.lane].role || "pi").toLowerCase();
        if (d.awarded) {
            awarded_class = ' awarded';
        }
        return type + '  ' + role + " " + d.class + awarded_class;
    }


    function display() {

        var rects, labels
                , minExtent = d3.time.day(brush.extent()[0])
                , maxExtent = d3.time.day(brush.extent()[1])
                , visItems = items.filter(function (d) {
                    return d.start < maxExtent && d.end > minExtent
                });

        mini.select('.brush').call(brush.extent([minExtent, maxExtent]));

        x1.domain([minExtent, maxExtent]);

        if ((maxExtent - minExtent) > 1468800000 * 4) {
            x1DateAxis.ticks(d3.time.months, 1).tickFormat(d3.time.format('%b'))
            x1MonthAxis.ticks(d3.time.years, 1).tickFormat(d3.time.format('%Y'))
        }
        else if ((maxExtent - minExtent) > 1468800000) {
            x1DateAxis.ticks(d3.time.mondays, 1).tickFormat(d3.time.format('%a %d'))
            x1MonthAxis.ticks(d3.time.mondays, 1).tickFormat(d3.time.format('%b - Week %W'))
        }
        else if ((maxExtent - minExtent) > 172800000) {
            x1DateAxis.ticks(d3.time.days, 1).tickFormat(d3.time.format('%a %d'))
            x1MonthAxis.ticks(d3.time.mondays, 1).tickFormat(d3.time.format('%b - Week %W'))
        }
        else {
            x1DateAxis.ticks(d3.time.hours, 4).tickFormat(d3.time.format('%I %p'))
            x1MonthAxis.ticks(d3.time.days, 1).tickFormat(d3.time.format('%b %e'))
        }


        //x1Offset.range([0, x1(d3.time.day.ceil(now) - x1(d3.time.day.floor(now)))]);

        // shift the today line
        main.select('.main.todayLine')
                .attr('x1', x1(now) + 0.5)
                .attr('x2', x1(now) + 0.5);

        // update the axis
        main.select('.main.axis.date').call(x1DateAxis);
        main.select('.main.axis.month').call(x1MonthAxis)
                .selectAll('text')
                .attr('dx', 5)
                .attr('dy', 12);

        // upate the item rects
        rects = itemRects.selectAll('rect')
                .data(visItems, function (d) {
                    return d.id;
                })
                .attr('x', function (d) {
                    return x1(d.start);
                })
                .attr('width', function (d) {
                    return x1(d.end) - x1(d.start);
                });

        rects.enter().append('rect')
                .attr('x', function (d) {
                    return x1(d.start);
                })
                .attr('y', function (d) {
                    return y1(lane_map[d.lane].position) + .1 * y1(1) - 3;
                })
                .attr('width', function (d) {
                    return x1(d.end) - x1(d.start);
                })
                .attr('height', function (d) {
                    return .8 * y1(1);
                })
                .attr('data-rect-tip', tip_text_html)
                .attr('class', function (d) {
                    return item_class(d, 'mainItem');
                });

        rects.exit().remove();

        set_tips('[data-rect-tip]', 'data-rect-tip');

        // update the item labels
        labels = itemRects.selectAll('text')
                .data(visItems, function (d) {
                    return d.id;
                })
                .attr('x', function (d) {
                    return x1(Math.max(d.start, minExtent)) + 2;
                });

        labels.enter().append('text')
                .text(function (d) {
                    var dollars = "  " + numeral(d.adirect).format("$0,0");
                    if (d.adirect < 1)
                        dollars = "";
                    return d.desc + dollars;
                })
                .attr('x', function (d) {
                    return x1(Math.max(d.start, minExtent)) + 2;
                })
                .attr('y', function (d) {
                    return y1(lane_map[d.lane].position) + .6 * y1(1);
                })
                .attr('text-anchor', 'start')
                .attr('class', 'itemLabel');

        labels.exit().remove();
    }

    function moveBrush() {
        var origin = d3.mouse(this)
                , point = x.invert(origin[0])
                , halfExtent = (brush.extent()[1].getTime() - brush.extent()[0].getTime()) / 2
                , start = new Date(point.getTime() - halfExtent)
                , end = new Date(point.getTime() + halfExtent);

        brush.extent([start, end]);
        display();
    }

// generates a single path for each item class in the mini display
// ugly - but draws mini 2x faster than append lines or line generator
// is there a better way to do a bunch of lines as a single path with d3?
    function getPaths(items) {
        var paths = {}, d, offset = .5 * y2(1) + 0.5, result = [];
        for (var i = 0; i < items.length; i++) {
            d = items[i];
            lane = lane_map[d.lane];
            role = lane.role;
            awarded = d.awarded ? " awarded" : "";
            path_key = d.class + " " + role + awarded;
            if (!paths[path_key]) paths[path_key] = '';
            paths[path_key] += ['M', x(d.start), (y2(lane.position) + offset), 'H', x(d.end)].join(' ');
        }

        for (var className in paths) {
            result.push({class: className, path: paths[className]});
        }

        return result;
    }

    function tip_text_html(item) {
        // (role)
        // Sequence Number
        // title
        // Award $
        // Budget start  - Budget end
        lane = lane_map[item.lane];
        content = [];
        content.push("<span class='bold'>Role: </span>" + lane.role);
        content.push("<span class='bold'>Sequence Number: </span>" + item.desc);
        content.push("<span class='bold'>Title: </span>" + lane.label);
        if (item.adirect > 0)
            content.push("<span class='bold'>Award: </span>" + numeral(item.adirect).format("$0,0"));
        else
            content.push("<span class='bold'>Not Awarded</span>");

        content.push("<span class='bold'>Budget Start: </span>" + moment(item.start).format('M/D/YYYY'));
        content.push("<span class='bold'>Budget End: </span>" + moment(item.end).format('M/D/YYYY'));
        return encodeURI(content.join("<br/>"));
    }

    function lane_text_html(lane) {
        // (role)
        // title
        // Award $
        content = [];
        content.push("<span class='bold'>Role: </span>" + lane.role);
        content.push("<span class='bold'>Title: </span>" + lane.label);
        if (lane.adirect > 0)
            content.push("<span class='bold'>Award: </span>" + numeral(lane.adirect).format("$0,0"));
        else
            content.push("<span class='bold'>Not Awarded</span>");

        return encodeURI(content.join("<br/>"));
    }

    function map_lanes(lanes) {
        map = {};
        lane_index = -1;
        lanes.forEach(function (d) {
            d.position = ++lane_index;
            map[d.id] = d;
        });
        return map;
    }

    function set_tips(selector, content_attribute) {
        $(selector).each(function () {
            $(this).qtip({
                content: {
                    text: decodeURI($(this).attr(content_attribute))
                },
                position: {
                    target: 'mouse',
                    adjust: { x: -55, mouse: false}
                }, style: {
                    classes: 'qtip-light calendar-tip',
                    tip: {
                        corner: true,
                        height: 24
                    }
                },
                hide: {
                    fixed: true,
                    delay: 100
                }
            });
        });
    }

});


</script>
</body>
</html>
