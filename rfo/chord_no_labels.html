<!DOCTYPE html>
<html data-ember-extension="1">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <link type="text/css" rel="stylesheet" href="styles/style.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery.nouislider.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery.nouislider.pips.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery-ui.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery-ui.structure.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jquery-ui.theme.min.css">

    <script src="javascript/moment.min.js"></script>
    <script src="javascript/numeral.min.js"></script>
    <script src="javascript/jquery-1.11.1.min.js"></script>
    <script src="javascript/jquery.nouislider.all.min.js"></script>
    <script type="text/javascript" src="javascript/d3.v3.min.js"></script>
    <script type="text/javascript" src="javascript/packagesv2.js"></script>
    <script src="javascript/jquery-ui.min.js"></script>
    <script src="javascript/sharedv2.js"></script>
    <style type="text/css">

        path.arc {
            cursor: move;
            fill: #fff;
        }

        .node {
            font-size: 10px;
        }

        .node:hover {
            fill: #1f77b4;
        }

        .link {
            fill: none;
            stroke: #1f77b4;
            stroke-opacity: .4;
            pointer-events: none;
        }

        .link.source, .link.target {
            stroke-opacity: 1;
            stroke-width: 2px;
        }

        .node.target {
            fill: #d62728 !important;
        }

        .link.source {
            stroke: #d62728;
        }

        .node.source {
            fill: #2ca02c;
        }

        .link.target {
            stroke: #2ca02c;
        }

        .pi_label {
            visibility: hidden;
        }

        .link.cross {
            stroke: green;
        }

    </style>
</head>
<body>
<h1 style="position:absolute; right:0px;"><i>Routing Form</i><br/>Co-occurrence</h1>
<aside style="margin-top:40px;">

    <div id="filters">
        <label for="autofilter">Filter</label>
        <input id="autofilter">

        <div id="selected_filters">
        </div>
    </div>

    <p>First Collaborations Between PIs Occurring from:<span id='latest_date'>Jan 1, 2011</span></p>


    <div id="slider" class="noUi-extended"></div>


    <p>This chord diagram visualizes co-occurrences in Routing Forms by PI.</p>

    <p>Each link represents two investigators that appeared in the same routing form. Hover on investigator to highlight
        links.
        Diagram can be rotated. Colored arcs represent colleges.
        Red links are those where the selected investigator is not the primary. Green links are those where the selected
        investigator is the primary.
    </p>

    <p>Built with <a href="http://d3js.org/">d3.js</a>.</p>


    <dl id="colors">
    </dl>
</aside>

<script type="text/javascript">

var w = 1250,
        h = 800,
        rx = w / 2,
        ry = h / 2,
        m0,
        rotate = 0;

var config = {};
config.color_by = "pi_college";
config.value_by = "value";
config.node_id = "rank";
config.primary_filter = "pi_college";
config.secondary_filter = "pi_department";
config.date_fields = ["earliest_collaboration"];
config.filter_date_field = "earliest_collaboration";
config.selected_filters_container = $('#selected_filters');
config.primary_filter_input = $('#autofilter');
config.primary_filter_prefix = 'College: ';
config.secondary_filter_prefix = 'Department: ';
config.node_label = 'pi';

var chord_radius = 120;
var cluster = d3.layout.cluster()
        .size([360, ry - chord_radius])
        .sort(function (a, b) {
            return d3.ascending(a.key, b.key);
        });

var bundle = d3.layout.bundle();

var line = d3.svg.line.radial()
        .interpolate("bundle")
        .tension(.85)
        .radius(function (d) {
            return d.y;
        })
        .angle(function (d) {
            return d.x / 180 * Math.PI;
        });

// Chrome 15 bug: <http://code.google.com/p/chromium/issues/detail?id=98951>
var div = d3.select("body").insert("div", "h2")
        .style("top", "-80px")
        .style("left", "-160px")
        .style("width", w + "px")
        .style("height", w + "px")
        .style("position", "absolute")
        .style("-webkit-backface-visibility", "hidden");


primary_filters_selected = ['Dentistry'];
secondary_filters_selected = [];


set_dates_by_index('#slider', '#latest_date', 1, 3);

var svg;

d3.json("data/only_all.json", function (all) {
    all_primary_filter_values = d3.set(all.nodes.map(function (node) {
        return node[config.primary_filter];
    })).values().sort();
    all_primary_filter_values.unshift("All");
    all_secondary_filter_values = d3.set(all.nodes.map(function (node) {
        return node[config.secondary_filter];
    })).values().sort();
    all_secondary_filter_values.unshift("All");
    map_primary_filter(all_primary_filter_values, '#colors', all_secondary_filter_values);
    all_values = all.links.map(function (node) {
        return parseInt(node[config.value_by]);
    });
    all_values = all_values.sort(function (a, b) {
        return a - b
    });
    set_domains_by_value(all_values[0], all_values[all_values.length - 1]);
    setup(all.links, all.nodes);
});

function setup(raw_links, raw_nodes) {
    all_nodes = raw_nodes;
    map_links(raw_links, all_nodes);
    render();
    animate_time('#slider', '#latest_date', 2, 3000);
}

function render() {
    filter_links(primary_filters_selected, first_link_dte, last_link_dte, false, 0, secondary_filters_selected);

    d3.select("svg").remove();
    if (!display_nodes[0] || !display_links[0]) return;

    clustered_nodes = cluster.nodes(packages.root(display_nodes));
    display_links = packages.map_ancestry(display_nodes, clustered_nodes, display_links);
    splines = bundle(display_links);

    svg = div.append("svg:svg")
            .attr("width", w)
            .attr("height", h)
            .append("svg:g")
            .attr("transform", "translate(" + rx + "," + ry + ")");

    svg.append("svg:path")
            .attr("class", "arc")
            .attr("d", d3.svg.arc().outerRadius(ry - chord_radius).innerRadius(0).startAngle(0).endAngle(2 * Math.PI))
            .on("mousedown", mousedown);

    var path = svg.selectAll("path.link")
            .data(display_links)
            .enter().append("svg:path")
            .attr("class", function (d) {
                classes = "link source-" + classify_pi(d.source.key) + " target-" + classify_pi(d.target.key);
                classes = d.source[config.primary_filter] !== d.target[config.primary_filter] ? classes + " cross" : classes;
                return classes;
            })
            .attr("d", function (d, i) {
                return line(splines[i]);
            })
            .attr('stroke-width', function (d) {return link_width_scale(d.value);});

    var groupData = svg.selectAll("g.group")
                .data(clustered_nodes.filter(function(d) { return (d.key && d.key.match(config.primary_filter_prefix) && d.children); }))
            .enter().append("group")
            .attr("class", "group");

    var groupArc = d3.svg.arc()
            .innerRadius(ry - (chord_radius - 2))
            .outerRadius(ry - (chord_radius - 35))
            .startAngle(function(d) {return (findStartAngle(d.__data__.children)-2) * Math.PI / 180;})
            .endAngle(function(d) {return (findEndAngle(d.__data__.children)+2) * Math.PI / 180;});


    var arc = svg.selectAll("g.arc")
                    .data(groupData[0])
                    .enter()
                    .append("svg:path")
                    .attr("d", groupArc)
                    .attr('id', function (d) {
                        return classify_pi(d.__data__.key.replace(config.primary_filter_prefix, ''));
                    })
                    .attr("class", "groupArc")
                    .style("fill", function (d) {
                        return primary_colors(d.__data__.key.replace(config.primary_filter_prefix, ''))
                    })
                    .style("fill-opacity", 0.8)
                    .append("svg:text")
                    .text(function (d, i) {
                        return d.__data__.key.replace(config.primary_filter_prefix, '');
                    })
            ;

    svg.selectAll("g.node")
            .data(clustered_nodes.filter(function (n) {
                return !n.children;
            }))
            .enter().append("svg:g")
            .attr("class", function (d) { return "node"; })
            .attr("id", function (d) {
                return "node-" + classify_pi(d.key);
            })
            .attr("transform", function (d) {
                return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")";
            })
            .append("svg:text")
            .attr("dx", function (d) {
                return d.x < 180 ? 8 : -8;
            })
            .attr("dy", ".31em")
            .attr("text-anchor", function (d) {
                return d.x < 180 ? "start" : "end";
            })
            .attr("transform", function (d) {
                return d.x < 180 ? null : "rotate(180)";
            })
            .attr('class', 'pi_label')
            .text(function (d) {
                return truncate_pi(d.key);
            })
            .on("mouseover", mouseover)
            .on("mouseout", mouseout);

}

d3.select(window)
        .on("mousemove", mousemove)
        .on("mouseup", mouseup);

function mouse(e) {
    return [e.pageX - rx, e.pageY - ry];
}

function mousedown() {
    m0 = mouse(d3.event);
    d3.event.preventDefault();
}

function mousemove() {
    if (m0) {
        var m1 = mouse(d3.event),
                dm = Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI;
        div.style("-webkit-transform", "translateY(" + (ry - rx) + "px)rotateZ(" + dm + "deg)translateY(" + (rx - ry) + "px)");
    }
}

function mouseup() {
    if (m0) {
        var m1 = mouse(d3.event),
                dm = Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI;

        rotate += dm;
        if (rotate > 360) rotate -= 360;
        else if (rotate < 0) rotate += 360;
        m0 = null;

        div.style("-webkit-transform", null);

        svg
                .attr("transform", "translate(" + rx + "," + ry + ")rotate(" + rotate + ")")
                .selectAll("g.node text")
                .attr("dx", function (d) {
                    return (d.x + rotate) % 360 < 180 ? 8 : -8;
                })
                .attr("text-anchor", function (d) {
                    return (d.x + rotate) % 360 < 180 ? "start" : "end";
                })
                .attr("transform", function (d) {
                    return (d.x + rotate) % 360 < 180 ? null : "rotate(180)";
                });
    }
}

function fade(opacity) {
    svg.selectAll('g.node').style('opacity', opacity);
    svg.selectAll("path.link")
            .style('opacity', opacity)
            .each(fadeNode(opacity));
}

function fadeNode(opacity) {
    return function (d) {
        target_node = "#node-" + classify_pi(d.target.key);
        source_node = "#node-" + classify_pi(d.source.key);
        svg.select(source_node).style("opacity", opacity);
        svg.select(target_node).style("opacity", opacity);
    };
}

function mouseover(d) {
    fade(0.1);
    svg.select("#node-" + classify_pi(d.key)).style("opacity", 1);
    svg.selectAll("path.link.target-" + classify_pi(d.key))
            .style('opacity', 1)
            .classed("target", true)
            .each(updateNodes("source", true));

    svg.selectAll("path.link.source-" + classify_pi(d.key))
            .style('opacity', 1)
            .classed("source", true)
            .each(updateNodes("target", true));
}

function mouseout(d) {
    fade(1);
    svg.selectAll('g.node')
            .style('opacity', 1);
    svg.selectAll("path.link.source-" + classify_pi(d.key))
            .classed("source", false)
            .each(updateNodes("target", false));

    svg.selectAll("path.link.target-" + classify_pi(d.key))
            .classed("target", false)
            .each(updateNodes("source", false));
}

function updateNodes(name, value) {
    return function (d) {
        if (value) this.parentNode.appendChild(this);
        svg.select("#node-" + classify_pi(d[name].key)).classed(name, value).style('opacity', 1);
    };
}

function cross(a, b) {
    return a[0] * b[1] - a[1] * b[0];
}

function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}

function findStartAngle(children) {
    var min = children[0].x;
    children.forEach(function(d) {
        if (d.children){
            d.children.forEach(function (e) {
                if (e.x < min)
                    min = e.x;
            })
        } else {
            if (d.x < min)
                min = d.x;
        }
    });
    return min;
}

function findEndAngle(children) {
    var max = children[0].x;
    children.forEach(function(d) {
        if (d.children) {
            d.children.forEach(function (e) {
                if (e.x > max)
                    max = e.x;
            })
        } else {
            if (d.x > max)
                max = d.x;
        }
    });
    return max;

}

</script>

</body>
</html>
